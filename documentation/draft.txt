Abstract:
Wir schlagen eine Erweiterung für die Programmiersprache IML vor, mit der auf einfache
Weise neue infix-Operatoren definiert werden können. Wir zeigen auf mit welchen Änderungen
am Lexer, Parser und der Grammatik eine solche Erweiterung implementiert werden kann.

Idee:

Lexikalische Syntax:
Erweiterung von "⟨ident⟩" um "⟨special⟩"-Charaktere zu erlauben: 
⟨ident⟩ ::= (⟨letter⟩(⟨letter⟩ | ⟨digit⟩ | ⟨special⟩ | ‘_’ | ‘’’)∗)⟨reservedid⟩


Grammatikalische Syntax:
Um neue Operatoren und ihre Präzedenz zu definieren erweitern wir die Grammatik wie folgt:


Definition eines neuen Operators "⟨ident⟩" mit Präzedenz "⟨literal⟩":
⟨decl⟩ ::= ⟨stoDecl⟩
       | ⟨funDecl ⟩
       | ⟨procDecl ⟩
       | ⟨operDecl ⟩

⟨operDecl⟩ ::= infix {⟨special⟩} ⟨literal⟩   

Ausserdem

Anhang: IML Testprogramm
program CustomOperator()
global
  infix ** 3

// TODO: handgeschriebene verbesserung von Dr. Lederer aufnehmen
fun operator**(a:int32, b:int32) returns result:int32
local
  var i:int32
do
 i init := 0;
 result init := a;
 while i < b do
  result := result * a;  
  i := i + 1;
 endwhile
endfun;

Und in der Verwendung:
 b := base_number ** call fib(2)


===========================================================

• Abstract
• Idee der Erweiterung mit konkreten Beispielen
• lexikalische Syntax
• grammatikalische Syntax
• überprüft von Fix&Foxi
• Kontext- und Typeinschränkungen
• Codeerzeugung
– erst im Schlussbericht
• Vergleich mit anderen Programmiersprachen
• Entwurfsalternativen
• Anhang: IML Testprogramme
– zum Test aller relevanten Eigenschaften der Erweiterung, insbesondere der Kontext- und Typeinschränkungen
– keine Einschränkung der Länge dieses Anhangs
• das Gewicht auf den einzelnen Punkten hängt stark vom gewählten Thema ab
• Schwerpunkt der Berichte ist die gewählte Erweiterung und ihre Einbindung in IML, nicht IML selbst