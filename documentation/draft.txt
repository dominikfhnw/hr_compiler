Abstract:
Wir schlagen eine Erweiterung für die Programmiersprache IML vor, mit der auf einfache
Weise neue infix-Operatoren definiert werden können. Wir zeigen auf mit welchen Änderungen
am Lexer, Parser und der Grammatik eine solche Erweiterung implementiert werden kann.

Idee:
Wir erweitern IML um eine Möglichkeit benutzerdefinierte Operatoren hinzuzufügen. Neue Operatoren
müssen im Deklarationsteil des IML-Programms angegeben werden (zB "infix ** 3", wobei 3 für die gewählte Präzedenz steht), und werden anschliessend in einer Funktion namens "operator**" definiert, 
Anschliessend kann der neue Operator wie jeder andere Infix-Operator verwendet werden.

Vergleich mit anderen Programmiersprachen:
Uns ist keine andere Programmiersprache bekannt in der komplett neue Operatoren definiert werden können. C++ bietet eine Möglichkeit an, bestehende Operatoren für neue Objekte zu definieren ("overload"). Wir haben die gleiche Namensgebung für unsere neuen Operatoren wie für Overloads in C++ gewählt, mit der Absicht dass 

Lexikalische Syntax:
Erweiterung von "⟨ident⟩" um "⟨special⟩"-Charaktere zu erlauben: 
⟨ident⟩ ::= (⟨letter⟩(⟨letter⟩ | ⟨digit⟩ | ⟨special⟩ | ‘_’ | ‘’’)∗)⟨reservedid⟩

Ausserdem wird "⟨symbol⟩" um die neu definierten Operatoren erweitert. Um dies zu erreichen muss das Programm eventuell in zwei Phasen gelext und geparst werden.

Grammatikalische Syntax:
Um neue Operatoren und ihre Präzedenz zu definieren erweitern wir die Grammatik wie folgt:

Definition eines neuen Operators "⟨ident⟩" mit Präzedenz "⟨literal⟩":
⟨decl⟩ ::= ⟨stoDecl⟩
       | ⟨funDecl ⟩
       | ⟨procDecl ⟩
       | ⟨operDecl ⟩

⟨operDecl⟩ ::= infix {⟨special⟩} ⟨literal⟩   

Ausserdem wird, je nach Präzedenz, einer der Grammatikregeln ⟨relopr⟩, ⟨addopr⟩ oder ⟨multopr⟩ mit dem neuen Operator ergänzt.

Anhang: IML Testprogramm
program CustomOperator()
global
  infix ** 3

  // TODO: handgeschriebene verbesserung von Dr. Lederer aufnehmen
  fun operator**(a:int32, b:int32) returns result:int32
  local
    var i:int32
  do
   i init := 0;
   result init := a;
   while i < b do
    result := result * a;  
    i := i + 1;
   endwhile
  endfun;
do
  debugout 2 ** 8
endprogram

Und in der Verwendung:
 b := base_number ** call fib(2)


===========================================================

• Abstract
• Idee der Erweiterung mit konkreten Beispielen
• lexikalische Syntax
• grammatikalische Syntax
• überprüft von Fix&Foxi
• Kontext- und Typeinschränkungen
• Codeerzeugung
– erst im Schlussbericht
• Vergleich mit anderen Programmiersprachen
• Entwurfsalternativen
• Anhang: IML Testprogramme
– zum Test aller relevanten Eigenschaften der Erweiterung, insbesondere der Kontext- und Typeinschränkungen
– keine Einschränkung der Länge dieses Anhangs
• das Gewicht auf den einzelnen Punkten hängt stark vom gewählten Thema ab
• Schwerpunkt der Berichte ist die gewählte Erweiterung und ihre Einbindung in IML, nicht IML selbst